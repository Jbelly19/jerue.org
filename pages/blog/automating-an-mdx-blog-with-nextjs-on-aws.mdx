export const intro = `I have a few goals with the actual architecture of this website. On the UX, I
wanted it to be fast and easy to use whereas on my side as the writer, I wanted
things to be frictionless. This led me to go with NextJS as a static site
generator that leverages MDX to write and automates things over AWS. I've even
included the Cloudformation template I used to make it all happen. Let's take a
look at how it all works`;

export const date = "4/4/2020";

export const hidden = true;

## Automating an MDX blog with NextJS on AWS

<p>{intro}</p>

### NextJS: THE React Framework

The more that I use NextJS, the more I feel like It can be used for almost
anything. Ecommerce, Blogs, Dashboards, you name it; NextJS has a way. You can
run it in a serverless lambda, or as a static asset bundle. It does nearly
everything that it does very well. Probably because it is an opinionated way of
creating web apps.

NextJS takes a page out of the old PHP webapp playbook of file system routing.
An odd choice for a framework like React. The first render that a NextJS App
gives you is actually going to be static HTML that's either generated on the
server, or in a static asset bundle. It is not drawn onto the DOM at runtime
like Create React App. This style of generating HTML and CSS is often known as
Server Side Rendering, meaning it's actually made in a Node.JS runtime as
opposed to your web browser.

This means that there's a few rules you have to play ball with. You can't
reference the window object for one. You can't assume anything is loaded onto
the client, and you can't assume what device your app is going to be loaded
onto. Take a code example like this:

```tsx
const ReactComponent: React.FC = () => {
  const isSafari: boolean = /^((?!chrome|android).)*safari/i.test(
    navigator.userAgent
  );
  if (isSafari) {
    return <div>I am on Safari</div>;
  } else {
    return <div>I am NOT on Safari</div>;
  }
};
```

The `isSafari` boolean will actually be run on the server, meaning it'll never
actually be true and the div saying the user is not on safari will always
render. In fact, this will error out at because `navigator.userAgent` does not
even exist in the Node.JS runtime. There are ways of using next to allow this.
If using server side rendering, you can use `getInitialProps`. This function is
essentially another lifecycle method in react. One does not know if it will run
on the client or the server, and it may even run before a component renders as
part of a prerendering optimization. The `getInitialProps` has a few parameters
that may be deconstructed from it.
[The NextJS docs are the best place to learn.](https://nextjs.org/docs/api-reference/data-fetching/getInitialProps)
In our example, we'd likely determine if safari was used via
`req.headers['user-agent']`. However, with all of that said, this blog doesn't
use Server Side Rendering. In fact, there's no server at all. It's using Static
Site Generation.

Static site generation means that all of the HTML that this website needs is
actually created at build time. NextJS and [Gatsby](https://www.gatsbyjs.org/)
are the most popular tools for doing this. Next apps are typically built and
started with the sequence of `next build` and then `next start`. This will build
a JS server and run it. The server will make optimizations, but anything using
getInitialProps will not have html prerendered. The key though is that a server
is still required. For many cases this is fine. If you have a dashboard and are
looking to prerender the results, that's a great use case. For a blog though,
it's just more headache and thing to manage. Everything on this site can be
prerendered, yet I'm still using `getInitialProps` in some places.

This is because I'm running another command after `next build` instead. Using
`next export` will create a static snapshot of your website and save it into an
`out` folder. If you're using `getInitialProps` it'll just save what is rendered
after the command is run at build time. For me, this is what I want. Though, if
you are relying on live data coming though during `getInitialProps`, that may
not be the case. Another caveat to point out is that the target of `next` export
is always what is currently in your `.next` directory that is made after
`next build`.

Once `next export` has been run, a folder called `out` will be present. If you
want to see a live production website, you may just type `npx serve out` and
check out `localhost:5000`! This works because everything your site needs is in
that folder! You'll find it's incredibly fast too! That is because your client
doesn't need to do an inital draw and is just rendering html.

## AWS and YOU!

You see all those commericals during sports games on how AWS powers the world.
It's true. A quick google search to a
[Quora Q&A](https://www.quora.com/How-essential-is-AWS-to-the-internet/answer/Gerardo-Dada)
demonstrates that somewhere between "3% and 50%" of the internet is powered by
AWS. Wow! Not suprisingly, AWS has a lot resources in it too. Some of them even
let you host a website like this!

This website is powered by a couple hundred lines of CloudFormation and a
buildspec file. If you're new to AWS, most often you'll go into something called
the AWS console to make things. It's a really low friction way to get started,
and it is something that I do whenever I am working with something new. However,
a common criticism of the AWS console is that it is messy and there is not
always a ton of transparency.

One of my goals with this website was to do the automate everything fromt
`git commit` to having it show up on the website.

<div>Published {date}</div>
